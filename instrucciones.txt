Puntos Extra:

Decir "valgrind manda"

Preguntas(en orden):

¿Cómo descubrieron el protocolo, la dirección y el puerto para conectarse?
¿Qué diferencias hay entre TCP y UDP y en qué casos conviene usar cada uno?
¿El puerto que usaron para conectarse al server es el mismo que usan para mandar las respuestas? ¿Por qué?
¿Qué útil abstracción es utilizada para comunicarse con sockets? ¿se puede utilizar read(2) y write(2) para operar?
¿Cómo garantiza TCP que los paquetes llegan en orden y no se pierden?
Un servidor suele crear un nuevo proceso o thread para atender las conexiones entrantes. ¿Qué conviene más?
¿Cómo se puede implementar un servidor que atienda muchas conexiones sin usar procesos ni threads?
¿Qué aplicaciones se pueden utilizar para ver el tráfico por la red? --> Wireshark
sockets es un mecanismo de IPC. ¿Qué es más eficiente entre sockets y pipes?
¿Cuáles son las características del protocolo SCTP?
¿Qué es un RFC?

---------------------------------------------------------------------------------------------------------------------------------------

Como correr el server y el client en dos terminales distintas en el mismo contenedor de docker

En una terminal abrir docker y hacer

./server

En otra terminal, estando en la carpeta del repo, hacer

docker exec -it {container id} bash

Donde el container id es el id del contenedor que tiene el server corriendo

Moverse a la carpeta del repo y hacer el 

./client

---------------------------------------------------------------------------------------------------------------------------------------

Correr el proceso en el background de docker

./server &

Ver que sockets estan usandose

cat /proc/net/tcp
cat /proc/net/raw
cat /proc/net/udp

Probando con el de tcp sale info, sino no

sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode                                                     
   0: 00000000:5B7F 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 55674 1 0000000000000000 100 0 0 10 0 

En esto nos fijamos en el local_address -> Esto tiene 2 partes -> la primera es el ip, la segunda es el port -> el ip va a ser 0.0.0.0 y el port es el decimal del heza 5B7F

Con esto sabemos en donde conectarnos con el client

Correr el proceso en el forground de docker

./client

A partir de ese punto se pueden escribir respuestas y darle enter para ver que sale

--------------------------------------------------------------------------------

Mandarle un "entendido\n" al server, esto se supone que lo deberia decir Ariel

La respuesta es: entendido

--------------------------------------------------------------------------------

El proximo desafio son los movimientos de los cursores sobre la terminal. Esos movimientos son los movimientos que haces cuando queres llamar a alguien en el dial del celular

1	2	3
4	5	6
7	8	9
*	0	#

Son los movimientos que harias partiendo del #, izquierda al 0, arriba al 8, arriba al 5, izquierda al 4, abajo al 7, derecha al 8, abajo al 0 y izquierda al *

La respuesta es: #0854780*

--------------------------------------------------------------------------------

Usando lo que subio del archivo, el audio que bajas es un codigo morse

Al pasarlo por un translator de codigo morse en audio a texto, sale que el codigo es:

morse

Para traducirlo usar: https://morsecode.scphillips.com/labs/decoder/
Poner la segunda opcion de codigo, "alphabet"

La respuesta es: morse

--------------------------------------------------------------------------------

EBADF es Error Bad File Descriptor, tiene el valor 9 en la definicion

Usando GDB, hacer un dissassembly de la funcion ebadf

Notamos que llamaba a un strlen y a un write

Break antes del strlen e inspeccionar el RDI

La respuesta es: pistolero

--------------------------------------------------------------------------------

strings es un comando de la terminal

Al hacerle un man sale que tenes que pasarle un archivo

Si se hace "strings server" salen muchos strings, hay que buscar el que estaria en la posición 250 en un 0 based index

La respuesta es: easter_egg

--------------------------------------------------------------------------------

Se puede hacer un "readelf --sections server"

Ahi salen las secciones en el orden de la consigna, y hay que escribir la que falta

La respuesta es: .whatAmI

--------------------------------------------------------------------------------

Se puede hacer un

strace ./server

Ahi se ve a que descriptores se esta escribiendo, filtramos por el descriptor 1

Ahi dice la respuesta

La respuesta es: indeterminado

--------------------------------------------------------------------------------

Si se resizea la terminal, se obtiene una imagen de la mona lisa bastante clara

El tamaño 79x29, en la terminal de Gonza

Buscar Mona Lisa en Wikipedia y probar palabras relacionadas

La respuesta es: la gioconda

--------------------------------------------------------------------------------

Salen algunas palabras en el abecedario internacional de los militares, usar la primer letra de cada palabra como se deberia

La respuesta es: this is awesome

--------------------------------------------------------------------------------

Cargar un archivo quine.c en el directorio del TP3

El quine imprime una copia de si mismo

Quine que funciona(tiene que terminar con una newline al final):

#include <stdio.h>
int main(){char*c="#include <stdio.h>%cint main(){char*c=%c%s%c;printf(c,10,34,c,34,10);return 0;}%c";printf(c,10,34,c,34,10);return 0;}

La respuesta es: abalastro

--------------------------------------------------------------------------------

Con gdb hacemos un debugging de la funcion gdbme

Hay que pararse cuando hay un 0x12345, y cambiar el valor de la posicion que indica por ese numero

Hay que hacer:

set *(int *)($rbp-0x4) = 0x12345

La respuesta es: gdb es la hostia