Puntos Extra:

Decir "valgrind manda"

Preguntas(en orden):

¿Cómo descubrieron el protocolo, la dirección y el puerto para conectarse?
¿Qué diferencias hay entre TCP y UDP y en qué casos conviene usar cada uno?
¿El puerto que usaron para conectarse al server es el mismo que usan para mandar las respuestas? ¿Por qué?
¿Qué útil abstracción es utilizada para comunicarse con sockets? ¿se puede utilizar read(2) y write(2) para operar?
¿Cómo garantiza TCP que los paquetes llegan en orden y no se pierden?
Un servidor suele crear un nuevo proceso o thread para atender las conexiones entrantes. ¿Qué conviene más?
¿Cómo se puede implementar un servidor que atienda muchas conexiones sin usar procesos ni threads?


----------------------------------------------------------------------------------------------------------------------------------------

Correr el proceso en el background de docker

./server &

Ver que sockets estan usandose

cat /proc/net/tcp
cat /proc/net/raw
cat /proc/net/udp

Probando con el de tcp sale info, sino no

sl  local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode                                                     
   0: 00000000:5B7F 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 55674 1 0000000000000000 100 0 0 10 0 

En esto nos fijamos en el local_address -> Esto tiene 2 partes -> la primera es el ip, la segunda es el port -> el ip va a ser 0.0.0.0 y el port es el decimal del heza 5B7F

Con esto sabemos en donde conectarnos con el client

Correr el proceso en el forground de docker

./client

A partir de ese punto se pueden escribir respuestas y darle enter para ver que sale

--------------------------------------------------------------------------------

Mandarle un "entendido\n" al server, esto se supone que lo deberia decir Ariel

La respuesta es: entendido

--------------------------------------------------------------------------------

El proximo desafio son los movimientos de los cursores sobre la terminal. Esos movimientos son los movimientos que haces cuando queres llamar a alguien en el dial del celular

1	2	3
4	5	6
7	8	9
*	0	#

Son los movimientos que harias partiendo del #, izquierda al 0, arriba al 8, arriba al 5, izquierda al 4, abajo al 7, derecha al 8, abajo al 0 y izquierda al *

La respuesta es: #0854780*

--------------------------------------------------------------------------------

Usando lo que subio del archivo, el audio que bajas es un codigo morse

Al pasarlo por un translator de codigo morse en audio a texto, sale que el codigo es:

morse

Para traducirlo usar: https://morsecode.scphillips.com/labs/decoder/
Poner la segunda opcion de codigo, "alphabet"

La respuesta es: morse

--------------------------------------------------------------------------------

EBADF es Error Bad File Descriptor, tiene el valor 9 en la definicion

Usando GDB, hacer un dissassembly de la funcion ebadf

Notamos que llamaba a un strlen y a un write

Break antes del strlen e inspeccionar el RDI

La respuesta es: pistolero

--------------------------------------------------------------------------------

strings es un comando de la terminal

Al hacerle un man sale que tenes que pasarle un archivo

Si se hace "strings server" salen muchos strings, hay que buscar el que estaria en la posición 250 en un 0 based index

La respuesta es: easter_egg

--------------------------------------------------------------------------------

Se puede hacer un "readelf --sections server"

Ahi salen las secciones en el orden de la consigna, y hay que escribir la que falta

La respuesta es: .whatAmI

